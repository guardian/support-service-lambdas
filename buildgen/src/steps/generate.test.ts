import { generate } from './generate';
import { GeneratorConfig } from '../data/build';
import { Template } from '../util/templater';
import { warningFileName } from '../data/snippets/buildgenREADME.txt';

const expectedWarningFileHeader =
	'#\n' +
	'# The files listed below are managed by buildgen.\n' +
	'#\n' +
	'# To make changes without failing the build:\n' +
	'# 1. edit the build definition in buildgen/src/data/\n' +
	'# 2. run `pnpm buildgen` at the root\n' +
	'#\n' +
	'# For further details, see buildgen/README.md\n' +
	'#\n' +
	'# Generated file list:\n' +
	'#\n';

const expectedWarningFileFooter =
	'#\n' +
	'# This file is generated by buildgen/src/data/snippets/buildgenREADME.txt.ts';
describe('generate function', () => {
	const mockConfig: GeneratorConfig = {
		packages: [
			{
				name: 'package1',
				functionNames: ['package1-function1', 'package1-function2'],
			},
			{ name: 'package2' },
		],
	};
	const mockConfigSingle: GeneratorConfig = {
		packages: [
			{
				name: 'package1',
				functionNames: ['package1-function1', 'package1-function2'],
			},
		],
	};

	const testTemplates: Template[] = [
		{
			name: 'dynamic/template.ts',
			template: (data) => `// This is dynamic content for ${data.name}`,
		},
		{
			name: 'static/text.md',
			template: '# Static markdown content',
		},
		{
			name: 'static/config.json',
			template: {
				version: '1.0.0',
				type: 'config',
			},
		},
		{
			name: 'static/config.yaml',
			template: { name: 'static-yaml', version: 1 },
		},
	];

	it('should generate files for all packages when no package name is specified', () => {
		const result = generate(mockConfig, testTemplates);

		const expectedGitignoreContent =
			expectedWarningFileHeader +
			'dynamic/template.ts\n' +
			'static/text.md\n' +
			'static/config.json\n' +
			'static/config.yaml\n' +
			'buildgenREADME.txt\n' +
			expectedWarningFileFooter;

		// Compare with exact equality
		expect(result).toEqual([
			{
				relativePath: 'handlers/package1/dynamic/template.ts',
				content: '// This is dynamic content for package1',
			},
			{
				relativePath: 'handlers/package1/static/text.md',
				content: '# Static markdown content',
			},
			{
				relativePath: 'handlers/package1/static/config.json',
				content: JSON.stringify({ version: '1.0.0', type: 'config' }, null, 2),
			},
			{
				relativePath: 'handlers/package1/static/config.yaml',
				content: 'name: static-yaml\nversion: 1\n',
			},
			{
				relativePath: 'handlers/package1/' + warningFileName,
				content: expectedGitignoreContent,
			},
			{
				relativePath: 'handlers/package2/dynamic/template.ts',
				content: '// This is dynamic content for package2',
			},
			{
				relativePath: 'handlers/package2/static/text.md',
				content: '# Static markdown content',
			},
			{
				relativePath: 'handlers/package2/static/config.json',
				content: JSON.stringify({ version: '1.0.0', type: 'config' }, null, 2),
			},
			{
				relativePath: 'handlers/package2/static/config.yaml',
				content: 'name: static-yaml\nversion: 1\n',
			},
			{
				relativePath: 'handlers/package2/' + warningFileName,
				content: expectedGitignoreContent,
			},
			{
				relativePath: warningFileName,
				content:
					expectedWarningFileHeader +
					'handlers/package1/dynamic/template.ts\n' +
					'handlers/package1/static/text.md\n' +
					'handlers/package1/static/config.json\n' +
					'handlers/package1/static/config.yaml\n' +
					'handlers/package1/' +
					warningFileName +
					'\n' +
					'handlers/package2/dynamic/template.ts\n' +
					'handlers/package2/static/text.md\n' +
					'handlers/package2/static/config.json\n' +
					'handlers/package2/static/config.yaml\n' +
					'handlers/package2/' +
					warningFileName +
					'\n' +
					warningFileName +
					'\n' +
					expectedWarningFileFooter,
			},
		]);
	});

	it('should correctly map file paths for nested directories', () => {
		const nestedTemplates: Template[] = [
			{
				name: 'nested/dir/file.ts',
				template: 'nested file content',
			},
			{
				name: 'root-level.ts',
				template: 'root content',
			},
		];

		const result = generate(mockConfigSingle, nestedTemplates);

		expect(result).toEqual([
			{
				relativePath: 'handlers/package1/nested/dir/file.ts',
				content: 'nested file content',
			},
			{
				relativePath: 'handlers/package1/root-level.ts',
				content: 'root content',
			},
			{
				relativePath: 'handlers/package1/' + warningFileName,
				content:
					expectedWarningFileHeader +
					'nested/dir/file.ts\n' +
					'root-level.ts\n' +
					warningFileName +
					'\n' +
					expectedWarningFileFooter,
			},
			{
				relativePath: warningFileName,
				content:
					expectedWarningFileHeader +
					'handlers/package1/nested/dir/file.ts\n' +
					'handlers/package1/root-level.ts\n' +
					'handlers/package1/' +
					warningFileName +
					'\n' +
					warningFileName +
					'\n' +
					expectedWarningFileFooter,
			},
		]);
	});
});

package com.gu.productmove.zuora

import com.gu.newproduct.api.productcatalog.{Annual, BillingPeriod, Monthly}
import com.gu.productmove.AwsS3
import com.gu.productmove.GuStageLive.Stage
import com.gu.productmove.endpoint.move.ProductMoveEndpointTypes.{ErrorResponse, InternalServerError}
import com.gu.productmove.zuora.GetInvoiceItemsForSubscription.{InvoiceItemsForSubscription, PostBody, getZuoraQuery}
import com.gu.productmove.zuora.model.SubscriptionName
import com.gu.productmove.zuora.rest.{ZuoraGet, ZuoraRestBody}
import sttp.capabilities.zio.ZioStreams
import sttp.capabilities.{Effect, WebSockets}
import sttp.client3.*
import sttp.client3.httpclient.zio.HttpClientZioBackend
import sttp.client3.ziojson.*
import sttp.model.Uri
import zio.json.*
import zio.{IO, RIO, Task, URLayer, ZIO, ZLayer}
import com.gu.productmove.zuora.rest.ZuoraRestBody.ZuoraSuccessCheck.None

import java.time.format.DateTimeFormatter
import java.time.{LocalDate, LocalDateTime}
import scala.collection.immutable.ListMap
import math.Ordered.orderingToOrdered

object GetInvoiceItemsForSubscriptionLive:
  val layer: URLayer[ZuoraGet, GetInvoiceItemsForSubscription] =
    ZLayer.fromFunction(GetInvoiceItemsForSubscriptionLive(_))

private class GetInvoiceItemsForSubscriptionLive(zuoraGet: ZuoraGet) extends GetInvoiceItemsForSubscription:
  override def get(subscriptionName: SubscriptionName): IO[ErrorResponse, InvoiceItemsForSubscription] =
    zuoraGet.post[PostBody, InvoiceItemsForSubscription](
      uri"action/query",
      PostBody(getZuoraQuery(subscriptionName)),
      ZuoraRestBody.ZuoraSuccessCheck.None,
    )

trait GetInvoiceItemsForSubscription:
  def get(subscriptionName: SubscriptionName): IO[ErrorResponse, InvoiceItemsForSubscription]

object GetInvoiceItemsForSubscription {

  def getZuoraQuery(subscriptionName: SubscriptionName) =
    s"select Id, ChargeAmount, ChargeDate, InvoiceId FROM InvoiceItem where SubscriptionNumber = '${subscriptionName.value}'"

  case class PostBody(queryString: String)

  case class InvoiceItemsForSubscription(records: List[InvoiceItem]) {

    // This is the invoice generated by the cancellation
    def getNegativeInvoice: ZIO[Any, ErrorResponse, (String, List[InvoiceItem])] = getInvoicesSortedByDate.headOption
      .map(ZIO.succeed(_))
      .getOrElse(
        ZIO.fail(
          InternalServerError(
            s"Empty list of invoice items in response $records this is an error " +
              s"as we need the cancellation invoice items to carry out a refund",
          ),
        ),
      )

    def negativeInvoiceId = getNegativeInvoice.map(_._1)

    def negativeInvoiceItemId = getNegativeInvoice.map(_._2.head.Id)

    def getLastPaidInvoice = getInvoicesSortedByDate.tail.headOption
      .map(ZIO.succeed(_))
      .getOrElse(
        ZIO.fail(
          InternalServerError(
            s"There was only one invoice item in response $records this is an error " +
              s"as we need the cancellation invoice items to carry out a refund",
          ),
        ),
      )

    def lastPaidInvoiceAmount = getLastPaidInvoice.map(_._2.map(_.ChargeAmount).sum)

    def lastPaidInvoiceId = getLastPaidInvoice.map(_._1)

    private def getInvoicesSortedByDate: Map[String, List[InvoiceItem]] = {
      val invoices: Map[String, List[InvoiceItem]] = records.groupBy(_.InvoiceId)
      ListMap(invoices.toSeq.sortWith(getDate(_) > getDate(_)): _*)
    }

    private def getDate(i: (String, List[InvoiceItem])) =
      i._2.headOption.map(_.chargeDateAsDateTime).getOrElse(LocalDateTime.MIN)
  }

  case class InvoiceItem(
      Id: String,
      ChargeDate: String,
      ChargeAmount: BigDecimal,
      InvoiceId: String,
  ) {
    def chargeDateAsDateTime = LocalDateTime.parse(ChargeDate, DateTimeFormatter.ISO_OFFSET_DATE_TIME)
  }

  given JsonDecoder[InvoiceItemsForSubscription] = DeriveJsonDecoder.gen[InvoiceItemsForSubscription]
  given JsonDecoder[InvoiceItem] = DeriveJsonDecoder.gen[InvoiceItem]
  given JsonEncoder[PostBody] = DeriveJsonEncoder.gen[PostBody]

  def get(
      subscriptionName: SubscriptionName,
  ): ZIO[GetInvoiceItemsForSubscription, ErrorResponse, InvoiceItemsForSubscription] =
    ZIO.serviceWithZIO[GetInvoiceItemsForSubscription](_.get(subscriptionName))
}

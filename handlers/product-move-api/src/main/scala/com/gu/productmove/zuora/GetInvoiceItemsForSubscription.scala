package com.gu.productmove.zuora

import com.gu.newproduct.api.productcatalog.{Annual, BillingPeriod, Monthly}
import com.gu.productmove.AwsS3
import com.gu.productmove.GuStageLive.Stage
import com.gu.productmove.endpoint.move.ProductMoveEndpointTypes.{ErrorResponse, InternalServerError}
import com.gu.productmove.zuora.GetInvoiceItemsForSubscription.{
  InvoiceItem,
  InvoiceItemWithTaxDetails,
  InvoiceItemsForSubscription,
  InvoiceItemsResponse,
  PostBody,
  TaxationItems,
  TaxDetails,
  getInvoiceItemsQuery,
  getTaxationItemsQuery,
}
import com.gu.productmove.zuora.model.SubscriptionName
import com.gu.productmove.zuora.rest.{ZuoraGet, ZuoraRestBody}
import sttp.capabilities.zio.ZioStreams
import sttp.capabilities.{Effect, WebSockets}
import sttp.client3.*
import sttp.client3.httpclient.zio.HttpClientZioBackend
import sttp.client3.ziojson.*
import sttp.model.Uri
import zio.json.*
import zio.{IO, RIO, Task, URLayer, ZIO, ZLayer}

import java.time.format.DateTimeFormatter
import java.time.{LocalDate, LocalDateTime}
import scala.collection.immutable.ListMap
import math.Ordered.orderingToOrdered

object GetInvoiceItemsForSubscriptionLive:
  val layer: URLayer[ZuoraGet, GetInvoiceItemsForSubscription] =
    ZLayer.fromFunction(GetInvoiceItemsForSubscriptionLive(_))

private class GetInvoiceItemsForSubscriptionLive(zuoraGet: ZuoraGet) extends GetInvoiceItemsForSubscription:
  override def get(subscriptionName: SubscriptionName): IO[ErrorResponse, InvoiceItemsForSubscription] = {
    for {
      invoiceItems <- zuoraGet.post[PostBody, InvoiceItemsResponse](
        uri"action/query",
        PostBody(getInvoiceItemsQuery(subscriptionName)),
        ZuoraRestBody.ZuoraSuccessCheck.None,
      )
      taxationItems <-
        if (invoiceIncludesTax(invoiceItems.records)) {
          println("Invoice items have tax, fetching taxation items")
          zuoraGet
            .post[PostBody, TaxationItems](
              uri"action/query",
              PostBody(getTaxationItemsQuery(invoiceItems.records.head.InvoiceId)),
              ZuoraRestBody.ZuoraSuccessCheck.None,
            )
            .map { items =>
              println("Got taxation items")
              items.records
            }
        } else ZIO.succeed(Nil)
    } yield InvoiceItemsForSubscription(
      invoiceItems.records.map(i =>
        InvoiceItemWithTaxDetails(
          i.Id,
          i.ChargeDate,
          i.ChargeAmount,
          if (i.TaxAmount != 0) {
            println(s"Tax amount for invoice item $i is ${i.TaxAmount} searching for matching taxation item")
            val item = taxationItems.find(_.InvoiceItemId == i.Id)
            if (item.isDefined)
              println(s"Found taxation item $item")
            else
              println("Couldn't find taxation item")
            item.map(taxationItem => TaxDetails(i.TaxAmount, taxationItem.Id))
          } else {
            None
          },
          i.InvoiceId,
        ),
      ),
    )
  }

private def invoiceIncludesTax(invoiceItems: List[InvoiceItem]) =
  invoiceItems.exists(_.TaxAmount > 0)

trait GetInvoiceItemsForSubscription:
  def get(subscriptionName: SubscriptionName): IO[ErrorResponse, InvoiceItemsForSubscription]

object GetInvoiceItemsForSubscription {

  def getInvoiceItemsQuery(subscriptionName: SubscriptionName) =
    s"select Id, ChargeAmount, TaxAmount, ChargeDate, InvoiceId FROM InvoiceItem where SubscriptionNumber = '${subscriptionName.value}'"

  def getTaxationItemsQuery(invoiceId: String) =
    s"select Id, InvoiceItemId, InvoiceId from TaxationItem where InvoiceId = '$invoiceId'"

  case class PostBody(queryString: String)
  case class TaxationItem(Id: String, InvoiceId: String, InvoiceItemId: String)
  case class TaxationItems(records: List[TaxationItem])
  case class InvoiceItemsForSubscription(items: List[InvoiceItemWithTaxDetails]) {

    // This is the invoice generated by the cancellation
    def getNegativeInvoice: ZIO[Any, ErrorResponse, (String, List[InvoiceItemWithTaxDetails])] =
      getInvoicesSortedByDate.headOption
        .map(ZIO.succeed(_))
        .getOrElse(
          ZIO.fail(
            InternalServerError(
              s"Empty list of invoice items in response $items this is an error " +
                s"as we need the cancellation invoice items to carry out a refund",
            ),
          ),
        )

    def negativeInvoiceId = getNegativeInvoice.map { case (invoiceId, invoiceItems) =>
      invoiceId
    }

    def negativeInvoiceItems = getNegativeInvoice.map { case (invoiceId, invoiceItems) =>
      invoiceItems
    }

    def getLastPaidInvoice: ZIO[Any, InternalServerError, (String, List[InvoiceItemWithTaxDetails])] = {
      val sorted = getInvoicesSortedByDate
      sorted.tail.headOption
        .map(ZIO.succeed(_))
        .getOrElse(
          ZIO.fail(
            InternalServerError(
              s"There was only one invoice item in response $items this is an error " +
                s"as we need the cancellation invoice items to carry out a refund",
            ),
          ),
        )
    }

    def lastPaidInvoiceAmount = getLastPaidInvoice.map { case (invoiceId, invoiceItems) =>
      invoiceItems.map(invoice => invoice.ChargeAmount + invoice.TaxDetails.map(_.amount).getOrElse(0)).sum
    }

    def lastPaidInvoiceId = getLastPaidInvoice.map(_._1)

    private def getInvoicesSortedByDate: Map[String, List[InvoiceItemWithTaxDetails]] = {
      val invoices: Map[String, List[InvoiceItemWithTaxDetails]] = items.groupBy(_.InvoiceId)
      ListMap(invoices.toSeq.sortWith(getDate(_) > getDate(_)): _*)
    }

    private def getDate(i: (String, List[InvoiceItemWithTaxDetails])) =
      i._2.headOption.map(_.chargeDateAsDateTime).getOrElse(LocalDateTime.MIN)
  }

  case class InvoiceItem(
      Id: String,
      ChargeDate: String,
      ChargeAmount: BigDecimal,
      TaxAmount: BigDecimal,
      InvoiceId: String,
  )

  case class InvoiceItemsResponse(records: List[InvoiceItem])

  case class TaxDetails(amount: BigDecimal, taxationId: String)
  case class InvoiceItemWithTaxDetails(
      Id: String,
      ChargeDate: String,
      ChargeAmount: BigDecimal,
      TaxDetails: Option[TaxDetails],
      InvoiceId: String,
  ) {
    def chargeDateAsDateTime = LocalDateTime.parse(ChargeDate, DateTimeFormatter.ISO_OFFSET_DATE_TIME)
    def amountWithTax = ChargeAmount + TaxDetails.map(_.amount).getOrElse(0)
  }

  given JsonDecoder[TaxationItems] = DeriveJsonDecoder.gen[TaxationItems]
  given JsonDecoder[TaxationItem] = DeriveJsonDecoder.gen[TaxationItem]
  given JsonDecoder[InvoiceItem] = DeriveJsonDecoder.gen[InvoiceItem]
  given JsonDecoder[InvoiceItemsResponse] = DeriveJsonDecoder.gen[InvoiceItemsResponse]
  given JsonEncoder[PostBody] = DeriveJsonEncoder.gen[PostBody]

  def get(
      subscriptionName: SubscriptionName,
  ): ZIO[GetInvoiceItemsForSubscription, ErrorResponse, InvoiceItemsForSubscription] =
    ZIO.serviceWithZIO[GetInvoiceItemsForSubscription](_.get(subscriptionName))
}

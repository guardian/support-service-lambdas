package com.gu.productmove.zuora

import com.gu.newproduct.api.productcatalog.{Annual, BillingPeriod, Monthly}
import com.gu.productmove.AwsS3
import com.gu.productmove.GuStageLive.Stage
import com.gu.productmove.zuora.GetInvoiceToBeRefunded.{GetInvoiceItemsResponse, PostBody, getZuoraQuery}
import com.gu.productmove.zuora.rest.{ZuoraGet, ZuoraRestBody}
import sttp.capabilities.zio.ZioStreams
import sttp.capabilities.{Effect, WebSockets}
import sttp.client3.*
import sttp.client3.httpclient.zio.HttpClientZioBackend
import sttp.client3.ziojson.*
import sttp.model.Uri
import zio.json.*
import zio.{IO, RIO, Task, URLayer, ZIO, ZLayer}
import com.gu.productmove.zuora.rest.ZuoraRestBody.ZuoraSuccessCheck.None

import java.time.format.DateTimeFormatter
import java.time.{LocalDate, LocalDateTime}
import scala.collection.immutable.ListMap
import math.Ordered.orderingToOrdered

object GetInvoiceToBeRefundedLive:
  val layer: URLayer[ZuoraGet, GetInvoiceToBeRefunded] = ZLayer.fromFunction(GetInvoiceToBeRefundedLive(_))

private class GetInvoiceToBeRefundedLive(zuoraGet: ZuoraGet) extends GetInvoiceToBeRefunded:
  override def get(subscriptionNumber: String): IO[String, GetInvoiceItemsResponse] =
    zuoraGet.post[PostBody, GetInvoiceItemsResponse](
      uri"action/query",
      PostBody(getZuoraQuery(subscriptionNumber)),
      ZuoraRestBody.ZuoraSuccessCheck.None,
    )

trait GetInvoiceToBeRefunded:
  def get(subscriptionNumber: String): IO[String, GetInvoiceItemsResponse]

object GetInvoiceToBeRefunded {

  def getZuoraQuery(subscriptionNumber: String) =
    s"select ChargeAmount, ChargeDate, InvoiceId FROM InvoiceItem where SubscriptionNumber = '$subscriptionNumber'"

  case class PostBody(queryString: String)

  case class GetInvoiceItemsResponse(records: List[InvoiceItem]) {
    
    // This is the invoice generated by the cancellation
    def getNegativeInvoice = getInvoicesSortedByDate.head

    def getLastPaidInvoice = getInvoicesSortedByDate.tail.head

    def getLastPaidInvoiceAmount = getLastPaidInvoice._2.map(_.ChargeAmount).sum

    def getInvoicesSortedByDate: Map[String, List[InvoiceItem]] = {
      val invoices: Map[String, List[InvoiceItem]] = records.groupBy(_.InvoiceId)
      ListMap(invoices.toSeq.sortWith(getDate(_) > getDate(_)): _*)
    }

    def getDate(i: (String, List[InvoiceItem])) =
      i._2.headOption.map(_.chargeDateAsDateTime).getOrElse(LocalDateTime.MIN)
  }

  case class InvoiceItem(
      ChargeDate: String,
      ChargeAmount: BigDecimal,
      InvoiceId: String,
  ) {
    def chargeDateAsDateTime = LocalDateTime.parse(ChargeDate, DateTimeFormatter.ISO_OFFSET_DATE_TIME)
  }

  given JsonDecoder[GetInvoiceItemsResponse] = DeriveJsonDecoder.gen[GetInvoiceItemsResponse]
  given JsonDecoder[InvoiceItem] = DeriveJsonDecoder.gen[InvoiceItem]
  given JsonEncoder[PostBody] = DeriveJsonEncoder.gen[PostBody]

  def get(subscriptionNumber: String): ZIO[GetInvoiceToBeRefunded, String, GetInvoiceItemsResponse] =
    ZIO.serviceWithZIO[GetInvoiceToBeRefunded](_.get(subscriptionNumber))
}
